<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Doc on Living and Programming - YJ Park&#39;s Blog</title>
    <link>http://blog.yjpark.org/categories/doc/</link>
    <description>Recent content in Doc on Living and Programming - YJ Park&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <managingEditor>yjpark@gmail.com (YJ Park)</managingEditor>
    <webMaster>yjpark@gmail.com (YJ Park)</webMaster>
    <copyright>This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.</copyright>
    <lastBuildDate>Sat, 07 Jan 2017 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://blog.yjpark.org/categories/doc/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Introduction to Dap Context</title>
      <link>http://blog.yjpark.org/blog/2017/01/07/introduction-to-dap-context/</link>
      <pubDate>Sat, 07 Jan 2017 00:00:00 +0000</pubDate>
      <author>yjpark@gmail.com (YJ Park)</author>
      <guid>http://blog.yjpark.org/blog/2017/01/07/introduction-to-dap-context/</guid>
      <description>

&lt;p&gt;Back in 2013, I was working on my first Unity3d game, it&amp;rsquo;s a simplified RTS game for tablets, the first version took us (3 developers including me) about 2 years to hit the iOS app store, did learned quite some lessons during the process, wanted to write some blogs for a long time, though never really did.&lt;/p&gt;

&lt;p&gt;We released the game at 2015, but the game wasn&amp;rsquo;t successful commercially, and our small start-up company run out of money. I was still making games after that, planned to reuse some lib codes created along the way. Then I realised that the quality of these libs can be improved much (due to time pressure, and lack of experiences)&lt;/p&gt;

&lt;p&gt;The most useful module was a custom data context class I wroted, it was rather simple, just an object with a bunch of properties, and event channels, both can be watched, e.g. when a property been set to a new value, all listeners will be triggered by a callback. On top of these properties and channels, I create a simple layer to interact with the data context via requests, such as &lt;code&gt;get&lt;/code&gt; or &lt;code&gt;set&lt;/code&gt; or &lt;code&gt;fire&lt;/code&gt;, then on top of that, I create a simple text parser so diffrent section in config files can trigger different action in the system, e.g.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;selection&amp;quot; : {
    &amp;quot;_&amp;quot;: [
        &amp;quot;sprite/destroy?key=selection&amp;quot;,
        &amp;quot;sprite/do?key=selection&amp;amp;prefab=squads.effect_sprite#color=1,1,1,0&amp;amp;sprite=flash&amp;amp;zoom=1.0&amp;amp;play.flash&amp;amp;done.flash=destroy&amp;quot;,
    ]
},
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first command will destroy the old selection sprite, the second command will create a new one (these objects are managed by a pool, so performance won&amp;rsquo;t be affected), then change it&amp;rsquo;s color, sprite, zoom value, then fire an event &lt;code&gt;play.flash&lt;/code&gt; which is an animation created by HoTween in the prefab, then when the event &lt;code&gt;done.flash&lt;/code&gt; been triggered (when the tween finished), destroy itself.&lt;/p&gt;

&lt;p&gt;This is used in our effect system, in the code, a bunch of entry points were defined, when certain things happened, the logic will check according section in the config file, then parse these commands and run them through the request system, which operates on the data contexts eventually.&lt;/p&gt;

&lt;p&gt;This works rather smoothly, so when non-dev members wants to tweak effects, they can just create prefabs, and writing commands to operate these prefabs, no code writing envolved, it&amp;rsquo;s a small challenge for them to learn and master the syntax, though after some documents and practice, the art works and dev works were de-coupled properly.&lt;/p&gt;

&lt;p&gt;Later the same system was used for GUI elements, in slightly different way, and also been used for charactor&amp;rsquo;s properties storage, though quite some boilerplate codes was written to make things work, the parsing logic became quite messy after adding more features, such as delayed execution, relative value changes&amp;hellip;&lt;/p&gt;

&lt;h2 id=&#34;what-s-dap&#34;&gt;What&amp;rsquo;s Dap&lt;/h2&gt;

&lt;p&gt;So I was working on the second version of my library codes, C# version, mainly used in Unity3d, though much of the codes are not limited to Unity3d, and can been used with DotNet, Mono, and Xamarin as well.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Dap&lt;/code&gt; stands for &lt;code&gt;Distributed Application Platform&lt;/code&gt;, the plan is to create conventions, api, and libraries for distributed applications, in my mind, it means:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Multiple platform support&lt;/li&gt;
&lt;li&gt;Multiple devices at the same time&lt;/li&gt;
&lt;li&gt;Real-time communication and colabration from these devices&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This is rather big scope, when I started thinking about this, was mainly focus on application dev, though much of the ideas are suitable for game dev as well, especially for network games.&lt;/p&gt;

&lt;h2 id=&#34;what-s-dap-context-aspect&#34;&gt;What&amp;rsquo;s Dap Context, Aspect&lt;/h2&gt;

&lt;p&gt;Dap is following ECS (Entity Component System), has following core concepts:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Context, it&amp;rsquo;s the entity in Dap, a little like Unity&amp;rsquo;s GameObject, though you can create subclass of Contexts.&lt;/li&gt;
&lt;li&gt;Aspect, it&amp;rsquo;s the component in Dap, everything related to a Context most likely are aspects&lt;/li&gt;
&lt;li&gt;The system in Dap can be done by either subclass from context, or with manners (special Aspects designed for sharing logic in defferent type of Entities)&lt;/li&gt;
&lt;li&gt;Env, it&amp;rsquo;s the runtime environment of the Dap system, there is only one env instance in the system, which is holding all the contexts&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Aspects are grouped to certain different categories in Context, these are the basic ones for all Contexts (you can also add new categories to subclasses as well):&lt;/p&gt;

&lt;h3 id=&#34;properties&#34;&gt;Properties&lt;/h3&gt;

&lt;p&gt;Holding values, which can be watched, when the valued been changed, all listeners will be notified. The value can be serialized, so can be saved to files or transfered over network.&lt;/p&gt;

&lt;p&gt;You can also provide checkers on the value, so can implement validation or authentication to the underlining values.&lt;/p&gt;

&lt;h3 id=&#34;channels&#34;&gt;Channels&lt;/h3&gt;

&lt;p&gt;Channels are used to fire events, which can be watched as well, each event can have a data with it.&lt;/p&gt;

&lt;p&gt;Note: here the data is a simple serialization format, support basic types.&lt;/p&gt;

&lt;h3 id=&#34;handlers&#34;&gt;Handlers&lt;/h3&gt;

&lt;p&gt;Handlers are used for request handling, requests can be sent to handlers, they will check the request data, do according operation, and then return a result.&lt;/p&gt;

&lt;h3 id=&#34;bus&#34;&gt;Bus&lt;/h3&gt;

&lt;p&gt;Bus is for more loose notification, e.g. since you can only listen to a channel when it&amp;rsquo;s already created, there is a timing issue to listen to future channels. Bus is just a simple message, with no data with it. You can also check whether a certain message have been sent as well.&lt;/p&gt;

&lt;h3 id=&#34;vars&#34;&gt;Vars&lt;/h3&gt;

&lt;p&gt;Wrapping for internal values or runtime values (not able to be serialized)&lt;/p&gt;

&lt;h3 id=&#34;manners&#34;&gt;Manners&lt;/h3&gt;

&lt;p&gt;Behaviors that can be added to multiple kind of contexts, e.g. Tickable is implemented as a Manner, means will listen to system&amp;rsquo;s tick channel, create a own tick channel, and fire a tick event accordingly.&lt;/p&gt;

&lt;p&gt;Also network logic are created as Manner, so they can be added to existing classes, so by following some simple rules (mostly naming conventions), a single player game can be turned into a network one by adding proper manners at client and server sides, the code changes should be rather small.&lt;/p&gt;

&lt;h2 id=&#34;where-s-the-code&#34;&gt;Where&amp;rsquo;s the Code&lt;/h2&gt;

&lt;p&gt;The core lib is available at github, there is no documents at the moment, and extra libraries (not open sourced yet) are needed to use it properly in real project, but the source codes can be used for understanding the concepts, so if you are interested, feel free to clone or fork:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/angeldnd/dap.core.csharp&#34;&gt;https://github.com/angeldnd/dap.core.csharp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>