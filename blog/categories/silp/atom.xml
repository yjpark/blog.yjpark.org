<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: silp | Living and Programming - YJ Park's Blog]]></title>
  <link href="http://blog.yjpark.org/blog/categories/silp/atom.xml" rel="self"/>
  <link href="http://blog.yjpark.org/"/>
  <updated>2014-04-13T17:20:12+08:00</updated>
  <id>http://blog.yjpark.org/</id>
  <author>
    <name><![CDATA[YJ Park]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SILP: Simple Individual Line Preprocessor]]></title>
    <link href="http://blog.yjpark.org/blog/2014/04/12/silp-simple-individual-line-preprocessor/"/>
    <updated>2014-04-12T20:18:15+08:00</updated>
    <id>http://blog.yjpark.org/blog/2014/04/12/silp-simple-individual-line-preprocessor</id>
    <content type="html"><![CDATA[<h2>Why bother with a preprocessor?</h2>

<p>I was quite busy working on our <a href="http://emberconflict.com/">RTS game on iPad</a> for almost a year, we are quite close to our first public version now. It&rsquo;s developed with Unity3d, using uLink as the network library. Created a quite nice data context system on Unity3d, so non-developers can update pure visual part of the system without developers' help, will write some entries on it later when got time.</p>

<p>SILP is a very small side project come from the process working on it. It&rsquo;s a simple language-agnostic preprocessor.</p>

<p>There are many discussions about whether a programming language should include preprocessor, most people seems agree that preprocessor is too error-prune and sacrifice readability too badly, and there should be seldom cases that an alternative can&rsquo;t be find to replace the preprocessor usage.</p>

<p>I agree that in most cases we don&rsquo;t need preprocessor though there are several cases that I would like to have a preprocessor in my tool set for cleaner codes or can remove some trivial typing. Here are 2 examples:</p>

<!--more-->


<h3>Common Import Statements</h3>

<p>In each project, most likely there will be some very common import statements that every source file want to include, e.g. logging and other utilities. In dynamic languages such as Python, it&rsquo;s not hard to inject them into the global namespace in some bootstrap functions, though in Java or Go it&rsquo;s not quite possible, each file has to have these lines.</p>

<p>Since Go support and recommend import from a git url, this is a bit more annoying. Here is a quick example.</p>

<p><code>go
import "github.com/golang/glog"
</code></p>

<p>It&rsquo;s both longer to type, and harder to change in the future, what if we need to change something in the source codes of the library? We can fork the source repository, and working on it, though we have to go over every source file and change the url of the import. It&rsquo;s not too hard with some tools like sed, though it&rsquo;s a bit ugly and fragile to me since we have to replace in text level.</p>

<p>Of course with just one import, it&rsquo;s not a big problem, though in practice, it&rsquo;s very easy to have several imports for every file, and quite some other imports grouped by file types (e.g. services that need db library, services that provide RPC calls&hellip;)</p>

<h3>Duplicate Codes</h3>

<p>Some time, it&rsquo;s not very easy to use usual way to remove duplicated codes, here is an example in Unity3d, it&rsquo;s a piece of our codes to check whether a user is already online in the system.</p>

<p>```csharp
private IEnumerator SaveArmyAsync(LobbyClient client, ArmyInfo armyInfo) {</p>

<pre><code>float startTime = Monitor.AddStartedEvent(LobbyMonitor.ARMY_SAVE_ARMY);

string error = LobbyNetError.ACCOUNT_ONLINE_WITH_OTHER_DEVICE;
IEnumerator checkOnline = client.CheckOnlinePlayer(_OnlinePlayerInfoBucket, () =&gt; {
    error = null;
});
while (checkOnline.MoveNext()) yield return checkOnline.Current;

if (error != null) {
    LobbyRPCUtils.SendNak(this, client, LobbyMonitor.ARMY_SAVE_ARMY, "RPC_SaveArmyFailed", error);
    yield break;
}
</code></pre>

<p>```</p>

<p>The logic here may not be very clear without full context, basically what it did is to create a event and send to our <a href="https://github.com/imvu-open/istatd">istatd server</a>, save the time into <code>startTime</code>, calling <code>client.CheckOnlinePlayer()</code> to check whether the user is logged in the system from other device, and calling <code>LobbyRPCUtils.SendNak()</code> to send a RPC call to the client if the user is already online.</p>

<p>The same structure is almost identical for all our server side RPC functions, only difference are the event id and RPC name, in this case <code>LobbyMonitor.ACCOUNT_LOGIN</code> and <code>RPC_OnLoginFailed</code>. As you can see, common functions are created to do most logic. But it&rsquo;s not very easy to make the whole pattern into a shorter format, because we have to follow the coroutine style here.</p>

<p>For example, line 3 ~ 7 are running <code>client.CheckOnlinePlayer()</code> in the coroutine way, and line 9 ~ 12 are handling the error case. We can&rsquo;t yield break in <code>client.CheckOnlinePlayer()</code> since it will only break it&rsquo;s own coroutine, instead of the outer one here.</p>

<p>Passing callback function into <code>client.CheckOnlinePlayer()</code> can solve the error handling, though still need the first trick, and the code will be less readable comparing with this way (using the callback style in many other places though).</p>

<p>If we are using a language supporting preprocessor, then we can easily create a macro here to do the duplicated works, though not possible in C#, until I created the SILP project, Our only option was just copy-paste.</p>

<h2>So What is SILP?</h2>

<p>After we have more RPC calls in the system sharing the similar code structure shown in last example, I decided to do something to improve it. Solve it in the language scope seems not a good option to me (only possible approach I figured possible was to wrap coroutine somehow and use some customized data structure to provide cleaner interface, both heavy and unnecessary), and I was thinking about finding a language-agnostic preprocessor for a while, so I spent some time to look for a existing project that I can use.</p>

<p>After a quick research, was a bit disappointed with the result, most of the preprocessors either are heavily limited to one language or provide way too much power than I need (so it&rsquo;s harder to learn and use). It&rsquo;s very clear that all I need is just a simple text substitution tools, so I created SILP and spend a whole day on it, the result is quite satisfying.</p>

<h3>How Simple SILP Is?</h3>

<p>There is zero logic in the syntax, currently all supported feature is parameter substitution in the template, and unless super useful, no complex feature will be added in the future.</p>

<p>SILP only handle individual line as well. All generated lines will be put back to the original file after the line with SILP syntax.</p>

<h3>When Should Use SILP?</h3>

<ul>
<li>Standard code block that&rsquo;s hard to be eliminated by regular technique.</li>
<li>Some small piece of logic that you don&rsquo;t want to wrap in a function and the language doesn&rsquo;t support inline functions.</li>
</ul>


<h3>When Should NOT Use SILP?</h3>

<ul>
<li>If you can remove duplicated code in language supported way.</li>
<li>The logic is not standard, and using SILP make them harder to read.</li>
</ul>


<h2>Full Example With SILP</h2>

<p>After implementing SILP, here is how I can remove the duplicated codes in the previous online player checking logic, here is the <code>silp_cs.md</code> file:</p>

<pre><code># LOBBY_SERVER_RPC_CHECK_ONLINE_PLAYER(eventId, nakRPC) #
```C#
float startTime = Monitor.AddStartedEvent(${eventId});

string error = LobbyNetError.ACCOUNT_ONLINE_WITH_OTHER_DEVICE;
IEnumerator checkOnline = client.CheckOnlinePlayer(_OnlinePlayerInfoBucket, () =&gt; {
    error = null;
});
while (checkOnline.MoveNext()) yield return checkOnline.Current;
if (error != null) {
    LobbyRPCUtils.SendNak(this, client, ${eventId}, ${nakRPC}, error);
    yield break;
}
```
</code></pre>

<p>The format is actually a valid <a href="https://help.github.com/articles/github-flavored-markdown">github flavored markdown</a>, only supported syntax is the h1 title (has to be like <code># macro(param1, param2) #</code>), and code block.</p>

<p>Here is the rendered image with the above example by <a href="http://markedapp.com/">Marked</a>, looks nice isn&rsquo;t it? (note that you need to toggle the <code>convert fenced code block</code> option)</p>

<p><img src="/images/silp/silp_example_marked.png"></p>

<p>Now all the RPC calls will be like this:</p>

<p>```csharp
private IEnumerator SaveArmyAsync(LobbyClient client, ArmyInfo armyInfo) {</p>

<pre><code>//SILP: LOBBY_SERVER_RPC_CHECK_ONLINE_PLAYER(LobbyMonitor.ARMY_SAVE_ARMY, "RPC_SaveArmyFailed")
float startTime = Monitor.AddStartedEvent(LobbyMonitor.ARMY_SAVE_ARMY);                            //__SILP__
                                                                                                   //__SILP__
string error = LobbyNetError.ACCOUNT_ONLINE_WITH_OTHER_DEVICE;                                     //__SILP__
IEnumerator checkOnline = client.CheckOnlinePlayer(_OnlinePlayerInfoBucket, () =&gt; {                //__SILP__
    error = null;                                                                                  //__SILP__
});                                                                                                //__SILP__
while (checkOnline.MoveNext()) yield return checkOnline.Current;                                   //__SILP__
if (error != null) {                                                                               //__SILP__
    LobbyRPCUtils.SendNak(this, client, LobbyMonitor.ARMY_SAVE_ARMY, "RPC_SaveArmyFailed", error); //__SILP__
    yield break;                                                                                   //__SILP__
}                                                                                                  //__SILP__
</code></pre>

<p>```</p>

<p>All lines end with <code>//__SILP__</code> are generated automatically, and can be regenerated with SILP, so if you want to adjust the logic in the future, should be very easy to do, and create a new RPC call is trivial as well, only need to write one line, and run SILP again (current manually, though it should be easy to make it automatically)</p>

<h2>What&rsquo;s Next</h2>

<p>Here is the repository: <a href="https://github.com/yjpark/silp">https://github.com/yjpark/silp</a></p>

<p>It&rsquo;s also available through PyPi, you can install with</p>

<p><code>
pip install silp
</code></p>

<p>Will first finish the documentation for what&rsquo;s working now, maybe adding more languages to default setting (mainly just how to add the special comments).</p>

<p>Maybe put the language configuration into the <code>silp_xx.md</code> file as well, though it might be more complicate to use and error-prone, so not sure about how to do this yet.</p>

<p>There are some interesting possibilities with editors here, e.g. set up code folding for SILP line and the generated line.</p>
]]></content>
  </entry>
  
</feed>
